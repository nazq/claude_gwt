import { supervisorModeTool } from '../../../../src/mcp/tools/supervisor';
import { WorktreeManager } from '../../../../src/core/git/WorktreeManager';
import { promises as fs } from 'fs';
import type { GitWorktreeInfo } from '../../../../src/types';

jest.mock('../../../../src/core/git/WorktreeManager');
jest.mock('fs', () => ({
  promises: {
    readFile: jest.fn(),
  },
}));

describe('MCP Tool: supervisor_mode', () => {
  const mockWorktreeManager = WorktreeManager as jest.MockedClass<typeof WorktreeManager>;
  const mockFs = fs as jest.Mocked<typeof fs>;

  const mockWorktrees: GitWorktreeInfo[] = [
    {
      path: '/test/project/main',
      branch: 'main',
      HEAD: 'abc123',
      isLocked: false,
      prunable: false,
    },
    {
      path: '/test/project/feature-auth',
      branch: 'feature-auth',
      HEAD: 'def456',
      isLocked: false,
      prunable: false,
    },
    {
      path: '/test/project/feature-api',
      branch: 'feature-api',
      HEAD: 'ghi789',
      isLocked: false,
      prunable: false,
    },
  ];

  beforeEach(() => {
    jest.clearAllMocks();
    jest.spyOn(process, 'cwd').mockReturnValue('/test/project');
  });

  it('should have correct tool definition', () => {
    expect(supervisorModeTool.definition.name).toBe('supervisor_mode');
    expect(supervisorModeTool.definition.description).toContain('supervisor mode');
    expect(supervisorModeTool.definition.inputSchema.properties.action.enum).toEqual(['enter', 'status', 'exit']);
  });

  it('should enter supervisor mode with multiple branches', async () => {
    mockWorktreeManager.prototype.listWorktrees = jest.fn().mockResolvedValue(mockWorktrees);

    const result = await supervisorModeTool.handler({ action: 'enter' });
    
    expect(result.content).toBeDefined();
    const text = (result.content[0] as any).text;
    expect(text).toContain('Phoenix Supervisor Mode Activated');
    expect(text).toContain('coordinate work across 3 branches');
    expect(text).toContain('• main');
    expect(text).toContain('• feature-auth');
    expect(text).toContain('• feature-api');
  });

  it('should handle enter action without explicit parameter', async () => {
    mockWorktreeManager.prototype.listWorktrees = jest.fn().mockResolvedValue(mockWorktrees);

    const result = await supervisorModeTool.handler({});
    
    expect(result.content).toBeDefined();
    expect((result.content[0] as any).text).toContain('Phoenix Supervisor Mode Activated');
  });

  it('should show status of all branches', async () => {
    mockWorktreeManager.prototype.listWorktrees = jest.fn().mockResolvedValue(mockWorktrees);
    
    mockFs.readFile
      .mockRejectedValueOnce(new Error('No task file')) // main
      .mockResolvedValueOnce('# Task: Implement authentication\nImplement OAuth2 login') // feature-auth
      .mockResolvedValueOnce('# Task: Build REST API\nCreate user endpoints'); // feature-api

    const result = await supervisorModeTool.handler({ action: 'status' });
    
    expect(result.content).toBeDefined();
    const text = (result.content[0] as any).text;
    expect(text).toContain('Phoenix Status Report');
    expect(text).toContain('• main: No task assigned');
    expect(text).toContain('• feature-auth: Task: Implement authentication');
    expect(text).toContain('• feature-api: Task: Build REST API');
  });

  it('should exit supervisor mode', async () => {
    mockWorktreeManager.prototype.listWorktrees = jest.fn().mockResolvedValue(mockWorktrees);

    const result = await supervisorModeTool.handler({ action: 'exit' });
    
    expect(result.content).toBeDefined();
    expect((result.content[0] as any).text).toContain('Exiting Phoenix supervisor mode');
  });

  it('should handle no branches', async () => {
    mockWorktreeManager.prototype.listWorktrees = jest.fn().mockResolvedValue([]);

    const result = await supervisorModeTool.handler({ action: 'enter' });
    
    expect(result.content).toBeDefined();
    expect((result.content[0] as any).text).toContain('No branches found');
    expect((result.content[0] as any).text).toContain('create_branch');
  });

  it('should handle unknown action', async () => {
    mockWorktreeManager.prototype.listWorktrees = jest.fn().mockResolvedValue(mockWorktrees);

    const result = await supervisorModeTool.handler({ action: 'unknown' as any });
    
    expect(result.content).toBeDefined();
    expect((result.content[0] as any).text).toContain('Unknown action: unknown');
    expect((result.content[0] as any).text).toContain("Use 'enter', 'status', or 'exit'");
  });

  it('should handle errors gracefully', async () => {
    mockWorktreeManager.prototype.listWorktrees = jest.fn().mockRejectedValue(
      new Error('Failed to list worktrees')
    );

    const result = await supervisorModeTool.handler({ action: 'enter' });
    
    expect(result.content).toBeDefined();
    expect((result.content[0] as any).text).toContain('Phoenix mode error');
    expect((result.content[0] as any).text).toContain('Failed to list worktrees');
  });
});